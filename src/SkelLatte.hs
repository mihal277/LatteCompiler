module SkelLatte where

-- Haskell module generated by the BNF converter

import AbsLatte
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transPIdent :: PIdent -> Result
transPIdent x = case x of
  PIdent string -> failure x
transPUIdent :: PUIdent -> Result
transPUIdent x = case x of
  PUIdent string -> failure x
transProgram :: Program -> Result
transProgram x = case x of
  Program topdefs -> failure x
transTopDef :: TopDef -> Result
transTopDef x = case x of
  FnDef type_ pident args block -> failure x
  ClassDef classheader classfields -> failure x
  StructDef structheader structfields -> failure x
transArg :: Arg -> Result
transArg x = case x of
  Arg type_ pident -> failure x
transClassHeader :: ClassHeader -> Result
transClassHeader x = case x of
  ClassDec puident -> failure x
  ClassDecExt puident type_ -> failure x
transClassField :: ClassField -> Result
transClassField x = case x of
  ClassFieldVar type_ items -> failure x
  ClassFieldMeth topdef -> failure x
transStructHeader :: StructHeader -> Result
transStructHeader x = case x of
  StructDec pident -> failure x
transStructField :: StructField -> Result
transStructField x = case x of
  StructField type_ items -> failure x
transBlock :: Block -> Result
transBlock x = case x of
  Block stmts -> failure x
transStmt :: Stmt -> Result
transStmt x = case x of
  Empty -> failure x
  BStmt block -> failure x
  Decl type_ items -> failure x
  Ass pident expr -> failure x
  ArrAss pident dimexpr expr -> failure x
  StructAss pident1 pident2 expr -> failure x
  Incr pident -> failure x
  Decr pident -> failure x
  Ret expr -> failure x
  VRet -> failure x
  Cond expr stmt -> failure x
  CondElse expr stmt1 stmt2 -> failure x
  While expr stmt -> failure x
  For type_ pident1 pident2 stmt -> failure x
  SExp expr -> failure x
transItem :: Item -> Result
transItem x = case x of
  NoInit pident -> failure x
  Init pident expr -> failure x
transType :: Type -> Result
transType x = case x of
  Int -> failure x
  Str -> failure x
  Bool -> failure x
  Void -> failure x
  Arr type_ -> failure x
  Class puident -> failure x
  Struct pident -> failure x
  Fun type_ types -> failure x
transExpr :: Expr -> Result
transExpr x = case x of
  EVar pident -> failure x
  ELitInt integer -> failure x
  ELitTrue -> failure x
  ELitFalse -> failure x
  EApp pident exprs -> failure x
  EAppMeth pident1 pident2 exprs -> failure x
  EObjVar pident1 pident2 -> failure x
  ENewArr type_ dimexpr -> failure x
  ENewObj puident -> failure x
  ENewSObj pident -> failure x
  EArrElem pident dimexpr -> failure x
  EString string -> failure x
  ENullSim pident -> failure x
  ENullCl puident -> failure x
  Neg expr -> failure x
  Not expr -> failure x
  EMul expr1 mulop expr2 -> failure x
  EAdd expr1 addop expr2 -> failure x
  ERel expr1 relop expr2 -> failure x
  EAnd expr1 expr2 -> failure x
  EOr expr1 expr2 -> failure x
transDimExpr :: DimExpr -> Result
transDimExpr x = case x of
  EDim expr -> failure x
transAddOp :: AddOp -> Result
transAddOp x = case x of
  Plus -> failure x
  Minus -> failure x
transMulOp :: MulOp -> Result
transMulOp x = case x of
  Times -> failure x
  Div -> failure x
  Mod -> failure x
transRelOp :: RelOp -> Result
transRelOp x = case x of
  LTH -> failure x
  LE -> failure x
  GTH -> failure x
  GE -> failure x
  EQU -> failure x
  NE -> failure x

